
## 组件分层设计思路
基础 UI 层：无业务
业务层组件：由基础 UI 组件组成，跟业务挂钩，例如一个查询组件封装了查询条件，表格和导入导出，同时跟后台接口约定一些固定传参字段，封装在里面。



## `npm` 发包

Verdaccio 私包


### `package.json` 入口模块字段
- `main`:  默认主入口，当库被其他项目通过 `require` 引用时，默认读取该字段指定的文件，否则用根目录下的 `index.js`。
- `module`:  `esm` 入口，用于 `import` 或 `export` 语句中。直接利用 ES 模块的静态结构，以实现 tree-shaking 等优化。
- `browser`：指定了一个专为浏览器环境设计的模块入口，提供了浏览器的兼容版本。例如 node 用 `http`，而浏览器中用 `xhr`。
- `types`:  `TS` 类型文件
- `exports`: 允许库定义多种导出方式和路径，以便根据用户的环境（Node.js 或浏览器）或 `CommonJS` / `ESM` 来提供相应的版本。
- `peerDependencies`:  使用外部项目的依赖。看有没有所需的依赖包，没有的话会自动安装，有的话就不安装，版本不匹配只发出警告。
- `peerDependenciesMeta`: 提供关于 `peerDependencies` 的额外信息。例如 `optional: true` 指示某些 `peerDependencies` 是可选的。 
- `engines`:  指定项目所需的 Node. Js 或 npm 版本，不符合将会有警告或报错。
- `packageManager`：主要服务与 node 的 `corepack enable`。确定项目中配置 `packageManager` 的包管理器及版本，并自动下载使用。
- `bin`：指定可执行文件的路径，主要用于编写一些命令行工具，使目录下的命令行工具可以直接被调用。
### `commonjs` /  `esm` 区别??
`commonjs`:  运行时 
`esm`：编译时


###  `rollup`


### `webpack`
- 目标格式
	- `output.library.type` 
	- `umd/cjs/esm/iife`?? 
	- 配置??？ 默认是 `iife` ？
- `chunk` 如何生成
	- `import() API`  => `async chunk`
	- `code spliting` => `chunk` 根据 `opxxxxx` 规则根据大小引用次数进行分包 ??


###  `pnpm` 
优势：?？
- 省空间-软连接???

文件名：
- ???

如何解决幽灵依赖：
- 项目里用了不在 `package.json` 声明的包，产生了幽灵依赖。通过把依赖包拉平

### 如何确定项目中包管理工具
- 看 `.lock` 文件。
- 如何确定项目中包管理工具的版本号？
	- `engines`
	- `packageManager`：node 的 `corepack enable`: 自动确定项目中配置 `packageManager` 的包管理器及版本，并下载使用


