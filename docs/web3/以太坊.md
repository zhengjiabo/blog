## ETH -Ethereum

### 基本概念

以太坊，称为区块链 2.0，设计了新的共识机制 ghost，使得出块时间可以减少到十几秒。

以太坊的挖矿（Mine Puzzle）对内存要求很高，限制了 ASIC 芯片的使用（ASIC resistance），防止其在挖矿中占据绝对优势，使得普通人也可以参与挖矿。

PoS（Proof of Stake）权益证明，股份投票决定下一个区块怎么产生。

比特币（BTC）最小单位：Satoshi
以太币（Ether）最小单位：Wei

去中心化货币好处：
- 跨国交易（对比法币）

智能合约（Smart contract ）：去中心化合约
- 跨国，不担心司法不同
- 不可能违约（代码执行）
- 不可篡改


## 账户模式

### BTC 基于交易的模型

BTC 交易时需要说明资金来源且证明合法性，且必须将资金来源 UTXO 都花出去，创建新的 UTXO（支出和找钱），不能只花一部分。

BTC 没有余额状态，隐私保密性比较好。不知道某人有多少钱，得去查 UTXO 集合和追溯历史记录。

### 以太坊基于账户的模型

以太坊基于账户模型，全节点维护了余额状态，**交易时不需要说明资金来源**。可以只花一部分，不需要找钱。跟现实的银行相似。

天然防范了前后链形式的 Double Spending Attack。
但产生了对应的 Reply Attack（重放攻击），用计数器（Nonce）记录账号有史以来的交易次数，发布交易时包含这个计数器。

全节点利用状态树维护余额等状态。

状态树：
- 余额
- Nonce（交易次数，是一个计数器，理论上叫 Count 更好）：交易时携带，防范 Reply Attack

### 账户类型 

- Externally owned account：外部账户（普通账户），公私钥控制。
	- 余额
	- Nonce（交易次数，是一个计数器，理论上叫 Count 更好）：交易时携带，防范 Reply Attack
- Smart contract account：合约账户。合约可以调用合约，但不能主动发起交易。
    - Nonce（交易次数，是一个计数器，理论上叫 Count 更好）：合约可以调用合约，防范 Reply Attack
    - Code：代码
    - Storage：相关存储（变量），调用合约基本都是在修改存储（变量）。

### 为什么要有账户系统

以太坊需要支持智能合约，**要求参与者要有比较稳定的身份**，基于账户系统。
需要隐私性强时可以根据不同情况创建不同账户。

？比特币就没有稳定身份？基于交易，隐私比较好，打一枪换一个地方，找回零钱可以写给其他账号。但是基于账户也可以全部余额都花掉，打一枪换一个地方，所以稳定身份是如何界定的？

比特币是没有账户概念的，只有一个公私钥，只有某个 UTXO 属于某个私钥。
一个人有多少钱是指他的私钥产出的签名，能有多少 UTXO，并没有账户或账户地址这个概念，从始至终就只有 UTXO 归属谁。
还有一个由公钥产生的钱包地址，用于交易时作为收款地址指定 UTXO 所属权。

？收款钱包地址跟交易输出的公钥是什么关系？UTXO 是如何根据哪些输入产生哪些输出的？

### 问题解答

一、比特币没有稳定身份吗，为什么
比特币没有账户概念，只有一个公私钥对，处理交易时并不直接关注地址，而是关注脚本。
我们说某些 UTXO 属于谁的，是人脑根据钱包地址去认定的。如果输出脚本不是标准的脚本（例如 P2PKH），那么比特币浏览器等工具是无法从输出脚本中解析出一个明确的地址，但这并不影响交易的有效性。

因为关注脚本，BTC 一笔交易是可以没有收款地址的，交易并不对应钱包地址。

只有某个 UTXO 属于某个私钥，
？钱包地址映射输出脚本
## 以太坊的数据结构

账户地址到账户状态的映射
Addr：state

以太坊账户地址 160 bits 即 20 bytes 
1 Bytes 等于 2 个 16 进制，即地址用 40 个 16 进制表示。

账户地址是由公钥取 hash，截断用后面 160 位作为账户地址。
以太坊账号地址和 BTC 钱包地址是不通用的，hash 算法不同。

数据结构：
哈希表
不好，因为验证余额状态时用 Merkle Proof，每次新块产生，只有很小一部分状态改变，而哈希表基于所有账户构建 Merkle Tree，代价太大了。
？验证余额为什么想到 Merkle Proof？
因为 Merkle Tree 可以维护全部节点的状态一致性，应该说状态要用 Merkle Tree 维护，随后验证可以用 Merkle Proof 验证。只不过最底下层用所有的账户，成本太大。

BTC 是基于交易模型，每次挖出新块，拿新块的交易构成 Merkle Tree，只有少量交易。
？那 BTC 的 UTXO 集合是如何维护的？如何验证的？UTXO 只存在内存中，如何保持一致？UTXO 集合等同余额状态，不用构建 Merkle Tree 进行验证吗？


Merkle Tree 的没有提供一个高效的查找和更新的方法。但有以下问题
- 没法高效查找
- 没法高效证明一个账户不存在
- 叶节点的顺序不一致，每个节点的 Merkle Tree 不是唯一的，导致计算后的 root hash 不一致。
为了解决这些问题，需要最底下的那一层排序，即叶节点排序，Sorted Merkle Tree。

BTC 不排序没有这些问题，是因为只有记账人选择交易，决定按怎样的顺序构建 Merkle Tree，确定了 Merkle Tree 的结构，这时候 Merkle Tree 已经是唯一的了，其他人只需要对这个已确定的 Merkle Tree 进行验证。

如果以太坊也学 BTC，则需要把这些状态写入到区块里，由记账人确定 Merkle Tree 结构，这样就是唯一的。
？那状态为什么不写入区块里，状态不写入区块目前是存在哪？存在账号里？账号又是存在哪？
写在区块里需要写所有账号的状态，比起 BTC 交易数大了好几个数量级，成本太大。

每次出块只有小部分状态改变，没必要写在区块里，每次出块都重复发布。账户状态应该维护在本地，需要解决保持一致的问题。

Sorted Merkle Tree 也有问题，产生新账户时，整个树都需要重新构建，成本太大。


Trie 数据结构（retrieval 信息检索，字典树，前缀树，也是 key value）是一颗多叉树

地址是 40 个 16 进制，每棵树分叉数目最多 17 个。根据 key 取值范围：0～f，加上结束标记位。（？结束标记位作用？）


？为什么说 key value 会出现碰撞。两个账户地址不一样，但有可能映射到 hash 表的同个位置？哈希表不是由账户地址映射到状态值吗？

Trie
- 账户地址不一样，不会出现碰撞。
- Trie 树是唯一的
- Trie 树添加新账户、更新状态，只会有少数节点需要重新构建。
- 开销较大，即使只有 1 分叉，也会单独存在节点。树的高度变得很大。

Patricia Tree（PT）：压缩路径的 trie
- 1 分叉的路径会压缩成一个。树的高度降低，访问时内存读取次数减少。但如果添加新账号有新的值导致增加分叉，压缩的路径会扩展开。
- 对键值分布（键这个值的发布）比较稀疏的压缩效率比较好

键：账户地址，160 位二进制，取值范围 2^160 特别特别大，抗碰撞性。所以账户地址在这个取值范围内分布很稀疏。

Merkle Tree 是哈希指针，Binary Tree 是内存指针


Merkle Patricia Tree（MPT）：对比 PT 把普通指针换成 hash 指针。MPT 也是 Merkle Tree

以太坊用的是 Modified MPT：
对 MPT 结构做了些修改，有 Extension Node、Branch Node。路径上存的是 hash 值，不是内存地址。

最终就是压缩路径，生成 root hash，写在 Block Header。（？如何生成 root hash 的，BTC 底层都是交易，hash 之后 hash，原本并没有其他中间节点存在。但 MPT 有）有是有，但存的都是 hash，最后整个作为输入产出 hash，继续存给顶层的节点。

以太坊 Block Header 有三个 root hash
- 状态树 Modified MPT
- 交易树
- 收据树？
- 存储树？（合约里的？）


状态树 MPT
- 防篡改，每个账户的状态都是正确的
- Merkle Proof，证明账号余额，证明账号不存在（证明 MPT 某个键不存在）。

发布新区块时，状态改变是通过新建分支，不是原地改，原来的状态是保存下来的。每个区块都有一个状态树。大部分节点是共享的，只有改变的节点会新建分支。

合约账号的存储也是用 MPT 保存。

以太坊是一颗大的 MPT，包含了很多小 MPT，每个合约账号都是一颗小 MPT。

每次新区块都是新建 MPT 不直接改的原因：
以太坊出块 10 几秒，软分叉很常见，分叉需要回滚，直接修改因为有智能合约，回滚困难，需要保存历史状态便于回滚。


Key 的管理方式解决了，状态 value 是通过 RLP 编码序列化后再存储。
RLP（Recursive Length Prefix）特点是简单，只支持字节数组嵌套   ？是啥


BLOCK header：
Parent hash： 上个区块块头 hash
Uncle hash：可能比 parent 大很多辈
Coinbase： 矿工地址
三个 root hash
- 状态树 Modified MPT
- 交易树
- 收据树
Bloom 跟收集树相关，提供高效查询符合某种交易的结果
Gas


Block struct：区块结构
Header
Uncles
Transaction



Extblock：真正发布出去 ？捋一下关系
Header
Uncles
Transaction




## 交易树

每次发布区块，区块里的交易组成交易树，跟 BTC 差不多，但用的是 MPT 。

路径不是用账号，而是交易在区块里的顺序。
只有当前区块的内容。

而状态树是系统中所有账户的状态都包含进去，不管这些账户和本次区块交易有没有关系，但会共享节点，只有状态修改的账户会新建分支，其他账号都是共享节点。

交易树在不同区块里都是相互独立的，不会共享节点。收据树也一样。




## 收据树

每个交易执行完，会形成一个收据，跟交易树节点一一对应，也是 MPT。


智能合约执行过程复杂，添加收据树有利于高效查询。


## 交易树/收据树

作用：
提供 Merkle Proof
复杂的查询操作

### Bloom Filter
