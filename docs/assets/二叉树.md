## 解题思维

### 「遍历」思维
通过遍历一遍二叉树得到答案

### 「分解问题」思维
子问题（子树）的答案推导出原问题的答案，写出递归函数的定义，并充分利用**返回值**

### 思考步骤
两个思维都需要通过以下步骤思考：
1. 单独抽出一个二叉树节点
2. 在这个二叉树需要做什么事?
3. 需要在 **（前/中/后序位置）** 分别做什么?

重点：**思维不要往下递归**，脑子的空间不够递归几次的。只要面对一个二叉树节点，递归函数会在所有节点执行相同的操作。


## 快速排序与归并排序
### 快速排序-前序遍历
快排思路： 
1. 对 `nums[lo..hi]` 进行排序，先找一个分界点 `p`。
2. 通过交换元素使得 `nums[lo..p-1]` 都小于等于 `nums[p]`，且 `nums[p+1..hi]` 都大于 `nums[p]`。
3. 递归地去 `nums[lo..p-1]` 和 `nums[p+1..hi]` 中寻找新的分界点，整个数组就被排序了。
```js
const sort = (nums, lo, hi) => {
	/****** 前序遍历位置 ******/
	// 通过交换元素构建分界点 p
    const p = partition(nums, lo, hi);
    /************************/
    
	sort(nums, lo, p - 1)
	sort(nums, p + 1, hi)
}
```
构造一个分界点，然后对左右子数组分别构造分界点。这跟二叉树的前序遍历一致，先对当前二叉树节点处理，然后对左右子树分别进行递归处理。


