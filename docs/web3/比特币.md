## 账本模式

比特币网络基于 UTXO 的账本模式，系统记录的是交易记录。

UTXO 集合，我们指的是当前所有未被花费的交易输出的集合。**一个 UTXO 如果已被花费，会从 UTXO 集合中移除，但仍然存放在 Block Body 中**，Block Body 保留了所有交易的历史记录，不管这些交易的输出是已被花费还是未被花费。区块链的**全节点**需要维护这个信息。

Block Body 保留的是**所有交易记录**，UTXO 集合只是**交易**中未被花费的集合。

UTXO 模型通过跟踪每个未花费的输出来确定账户的余额，在比特币系统中没有“账户”或“余额”的概念，**并没有一个全局变量记录了余额**。

虽然看起来通过钱包地址可以查询到“余额”，实际上这个余额是通过统计该钱包地址可以引用的所有 UTXO 计算出来的。

## UTXO
### 基础概念

比特币网络通过 UTXO (`Unspent Transaction Outputs` 未花费的交易输出)实现。

每个输入都是之前交易的一个输出（UTXO），而每个交易输出可以成为未来交易的输入。

Alice 拥有 10 个比特币并想要支付给 Bob 4 个比特币：
在创建交易时，Alice 的钱包需要明确指出是哪些 UTXO 被用作本次支付的资金来源。
- `Input: Alice address, Referenced UTXO value (10)`
- `Output 1: Bob address, Amount (4)`
- `Output 2: Alice new address (找零地址), Amount (6)`

这样，Alice 原来的 10 个比特币的 UTXO 就被消费了，而新生成的两个 UTXO（一个是 Bob 的 4 个比特币，一个是 Alice 的 6 个比特币找零）则可以在未来的交易中使用。

每次交易可以有多个输入，多个输出。这些输入可以来源不同地址（属于不同账号），交易有 n 个输入就需要有 n 个签名和公钥。

UTXO 存放在全节点的内存中，以便快速读取检测。

### UTXO 的结构

1. **交易哈希（Transaction Hash）**：产生 UTXO 的那笔交易的唯一标识符，也就是那笔交易的哈希值。它用于唯一地定位包含该 UTXO 的交易。
2. **输出索引（Output Index）**：这是指 UTXO 在其产生交易的输出列表中的位置。因为一笔交易可以有多个输出，所以需要索引来指定哪一个输出是 UTXO。
4. **金额（Amount）**：这是 UTXO 所持有的比特币数量，表示了这个 UTXO 的价值。
5. **脚本公钥（ScriptPubKey）**：这是一个锁定脚本，指定可以解锁该 UTXO 以进行消费的公钥。

### 资金来源

每次交易时，必须指明具体使用哪些 UTXO 作为资金来源。

指定资金来源 UTXO 时需要提供以下信息：
- 交易的 hash：指的是产生该 UTXO 的那笔交易的 hash 值。
- 输出下标：该 UTXO 在产生它的交易中作为第几个输出（从 0 开始计数）。

### 检验资金来源是否有效

全节点的 Block Body 存放了 UTXO 集合，且是存放在内存里，方便快速读取检测。

例如检验资金来源 UTXO 是否有效，只需要在 UTXO 集合中检验是否存在，信息是否一致。



### 交易费

交易费 = 交易大小 x 费率
- **交易大小**：指的是交易数据的字节大小。一笔交易包括输入、输出和签名等信息，其大小不是固定的。一般来说，交易的输入（来源）越多，交易的大小就越大，因此交易费也可能更高。
- **费率**：通常以“satoshi/byte”（satoshi 是比特币的最小单位，1 BTC = 100,000,000 satoshi）为单位。由用户自己设定，当网络繁忙时，用户可能会选择支付更高的费率以加快交易确认。

### Double spending attack

双重支付攻击：恶意攻击者尝试将同一笔资产同时支付给两个或多个不同的接收者的行为。防范双重支付攻需要用 id 和归属状态。

在比特币中是通过 UTXO 的交易 hash 和脚本公钥来解决的（分别对应 id 和归属状态）。

交易里面有一个公钥。发起交易者将会把公钥提供给接受者。而且交易里，币的来源指向的 UTXO 的输出，也有一个公钥指明了归属者。这两个公钥一对比就知道是否由币的拥有者发起的交易。



## 确认交易成立

6 个新区块（1 h）之后，只是概率上确认。


## Zero 确认？

应用很广，因为现实中很多因素允许这种乐观成立，例如电商从确认交易后有发货时间，超过 1 h，如果 1 h 后交易没成功，可以不发货。



## 交易冲突

交易被使用过（已经写到区块链里了），就需要在选择进入打包的交易里删除。

？对非法转发这块有点问题
？恶意节点如何进行 double spending attack
？恶意节点转发非法交易包含哪些情况


## 挖矿难度

比特币用的是 sha-256，产生 hash 是 256位。
H (Block Head) <= target

挖矿难度和目标阈值成反比，挖矿难度最小为 1，计算公式：
Difficult = difficult_1_target / target

Difficult_1_target：挖矿难度等于 1 时的目标阈值。


目标阈值（代码中用的是目标阈值）调整公式：
Target = target * 最近 2016 区块 actual time / expected time

目标阈值核验时可以判断字节前面 0 个数是否满足。因为难度越高，目标阈值越小，越小时前面 0 越多。


且有个最大限制，最大不超过 4 倍，最小不小于 1/4，避免遇到特殊情况，挖矿难度被设置得极大或极小

### 难度是如何调难度值，确保所有人都改
写在比特币代码中，都会去执行更改的，不用广播

### 恶意不调难度值
在难度上升时不调，hash 速度会比别人快。

但难度值编码后写在 block head 的 nBit 中，不调难度值将不被其他节点接受。

## 出块时间太短产生的问题

网络传播需要时间，传播时间不够，分叉严重且会成为常态，对区块链的共识不利。

总算力被分叉分散，恶意节点可以集中算力扩展一个分叉，使得替换主链（fu attack？）的攻击变得容易。

产生大量孤块。

## 全节点
？补充工作内容

## 轻节点
？补充工作内容

## 区块链的安全是如何保证的
	1.	密码学，私钥保证，别人无法转走你的账
	2.	区块链上大部分是好的节点，没有你的签名不会允许转走你的钱