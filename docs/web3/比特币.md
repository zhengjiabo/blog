


## 哈希

### 特性
- Puzzle friendly：通过某种方法预测或计算出特定的输出结果非常困难。没办法通过某种方法去人为控制输出结果的趋势。
- **不可逆性**(hiding)：从**哈希值无法直接推导出原始输入数据**。这意味着如果你只知道一个区块的哈希值，你不能确定是哪个特定的输入产生了这个哈希值。**要求输入要足够大，每个输入概率足够均匀。** 如果输入被限定范围，则可以遍历所有输入去暴力算出。
- **强抗碰撞性**：找到两个**不同的输入，它们产生相同的输出哈希值**，在计算上是**极其困难**的。这保证了区块链网络的安全性，防止了某些类型的攻击。
- **确定性**：对于**相同的输入数据**，哈希函数**总是产生相同的输出哈希值**。这意味着如果输入数据没有变化，无论执行多少次哈希运算，结果都是一致的。
- **高效性**：哈希函数能够**快速计算**出输入数据的哈希值，即使是对于很大的数据集也能高效处理。

> 签名用的随机源要确保随机，否则可能会泄露私钥（仅做了解，涉及密码学）
> （目前记得结论即可，签名的 Nonce 要随机，否则有风险。）签名由私钥、随机数、消息体 hash 生成。

## 节点

### 基础概念

比特币节网络中，任何机器都可以运行一个完整的比特币节点（全节点），包括: 
1. 钱包：用来发起交易，广播交易，跟踪和管理 UTXO。
2. 完整区块链：记录了所有交易历史，通过特殊的结构保证历史交易的安全性，并且用来验证新交易的合法性。
3. 矿工：通过记录交易及解密数学题来生成新区块，如果成功可以赚取奖励。
4. 路由功能：把其它节点传送过来的交易数据等信息再传送给更多的节点。

可以运行一个比特币的完整节点（全节点），当然这个比较消耗资源。一般用户都是使用**轻客户端或专用钱包软件**（轻节点），具备少量功能，可以进行交易创建。

### Full （validating）Node 全节点

保存所有信息，验证每一个交易。占资源大，存放了 Block Head，Block Body。


### Light （validating） Node 轻节点

区块链中大部分是轻节点，只有 Block Head，没法独立验证交易，需要利用区块链的信息（其他全节点的信息）做查询校验。最长见的是手机钱包 App。



## Merkle Tree

区块（ Block Body ）中用来存交易的数据结构。
Merkle Tree 生成的 root hash 存在了区块的 Block Head 里。用来验证 Block Body 里的交易是否被篡改，任何一个交易被修改，都会影响 root hash 生成。

![](../assets/20240313-07-23-18.png)


## 区块 Block
### Block Head

存储了宏观信息：
- BTC 比特币的的版本 vision
- 指向前一个区块的 hash 指针：指向上个区块的块头 Block Head，只有块头信息参与 hash。
- Merkle Tree 的 root hash（所有交易的根 hash），保障交易列表不被篡改。（挖矿时可以借用前 8 bytes 作为 Extra Nonce）
- 区块的创建时间 ntime
- nBit: 目标值 Target 的压缩编码
- Nonce：当前区块的随机值（4 bytes）

### Block Body

包含详细信息：
- Translaction List 交易列表/记录（一般用 Merkle Tree 数据结构读取）

> UTXO 集合不直接存储在 Block Body 中，而是全节点基于交易记录动态维护的状态信息。UTXO 存放在全节点的内存中，以便快速读取检测。

### 验证交易存在 proof of inclusion

轻节点利用 Merkle proof 去验证交易是否存在区块中。
Merkle proof ：在 Merkle Tree 中这个交易到根节点的路径。

Merkle proof 可以证明 Merkle Tree 里包含某个交易。时间成本很低，O (log (n))。

如果你转钱到我的账户，你需要提供 Merkle Proof。我验证后 root hash 一致，证明你转钱成功写到区块链里了。

首先轻节点向别的全节点，获取 Merkle Proof（路径）上每个节点所需要的 hash 值。通过这笔交易生成的 hash，沿着 Merkle Proof 从下往上验证，加上全节点提供的所需 hash，就可以计算出 root hash，root hash 与轻节点 Block Head 的 root hash 一致，这笔交易就在这个区块中。


### 恶意节点，提供错误 hash
Merkle Proof 依赖全节点提供的 hash，如果提供 hash 的全节点是恶意节点，提供错误 hash，导致交易验证失败。

轻节点不只依赖于一个全节点提供的信息，而是通过**多节点验证** Merkle Proof，并进行比较。如果大部分全节点提供了一致的信息，而少数节点提供了不同的信息，轻节点可以判断那些少数节点很可能是恶意的。

### 验证交易不存在

笨办法：验证整棵树，这样知道叶节点交易没被篡改，没在叶节点交易里就是不存在。

全节点整颗 Merkle Tree 发给轻节点，轻节点进行整棵树计算验证，如果 root hash 一致，证明树没被篡改，叶节点只有这些，这笔交易不在叶节点里，交易不存在。时间复杂度 O (n)

好的解决方案（比特币没有）：
叶节点有序（sorted merkle tree），只验证 merkle proof。
如果叶节点有序（根据 hash 从小到大），则找到交易这个节点应该插入的位置，将左右两个交易去走完 merkle proof，如果 roof hash 一致，证明这两个交易没被篡改，他们中间确实没有我们要找的这个交易。这样时间复杂度 O (log (n))。也不用去验证整棵树。



## 账本模式

比特币网络基于 UTXO 的账本模式，系统记录的是交易记录。

Block Body 保留了本区块的交易记录，不管在未来这些交易的输出是已被花费还是未被花费，这些交易都会在区块链中永久保存。

UTXO 集合，我们指的是当前所有未被花费的交易输出的集合，由全节点动态维护。**一个 UTXO 如果已被花费，会从 UTXO 集合中移除**。

区块链所有区块的 Block Body 集合在一起保留的是**所有交易记录**，UTXO 集合只是**交易记录**中未被花费的交易输出集合，是根据区块链的所有交易记录去动态维护的。

UTXO 模型通过跟踪每个未花费的输出来确定账户的余额，在比特币系统中没有“账户”或“余额”的概念，**并没有一个全局变量记录了余额**。

虽然看起来通过钱包地址可以查询到“余额”，实际上这个余额是通过统计该钱包地址可以引用的所有 UTXO 计算出来的。

没有维护全局变量：
- 余额需要通过钱包地址可以引用的所有 UTXO 计算出来的
- 每次交易都需要给出资金来源。

## UTXO
### 基础概念

比特币网络通过 UTXO (`Unspent Transaction Outputs` 未花费的交易输出)实现。

每个输入都是之前交易的一个输出（UTXO），而每个交易输出可以成为未来交易的输入。

Alice 拥有 10 个比特币并想要支付给 Bob 4 个比特币：
在创建交易时，Alice 的钱包需要明确指出是哪些 UTXO 被用作本次支付的资金来源。
- `Input: Alice address, Referenced UTXO value (10)`
- `Output 1: Bob address, Amount (4)`
- `Output 2: Alice new address (找零地址), Amount (6)`

这样，Alice 原来的 10 个比特币的 UTXO 就被消费了，而新生成的两个 UTXO（一个是 Bob 的 4 个比特币，一个是 Alice 的 6 个比特币找零）则可以在未来的交易中使用。

每次交易可以有多个输入，多个输出。这些输入可以来源不同地址（属于不同账号），交易有 n 个输入就需要有 n 个签名和公钥。

UTXO 存放在全节点的内存中，以便快速读取检测。

### UTXO 的结构

1. **交易哈希（Transaction Hash）**：产生 UTXO 的那笔交易的唯一标识符，也就是那笔交易的哈希值。它用于唯一地定位包含该 UTXO 的交易。
2. **输出索引（Output Index）**：这是指 UTXO 在其产生交易的输出列表中的位置。因为一笔交易可以有多个输出，所以需要索引来指定哪一个输出是 UTXO。
4. **金额（Amount）**：这是 UTXO 所持有的比特币数量，表示了这个 UTXO 的价值。
5. **锁定脚本**：指定可以解锁该 UTXO 以进行消费的公钥。

### 资金来源

每次交易时，必须指明具体使用哪些 UTXO 作为资金来源。

指定资金来源 UTXO 时需要提供以下信息：
- 交易的 hash：指的是产生该 UTXO 的那笔交易的 hash 值。
- 输出下标：该 UTXO 在产生它的交易中作为第几个输出（从 0 开始计数）。

### 检验资金来源是否有效

全节点内存中维护了 UTXO 集合，方便快速读取检测。

例如检验资金来源 UTXO 是否有效，只需要在 UTXO 集合中检验是否存在，信息是否一致。

当一个 UTXO 被花费后，它就会从 UTXO 集合中删除，新产生的 UTXO 保存在 UTXO 集合中。

### 交易费

矿工的激励，矿工选择交易的动力，争夺记账权后可以获得出块奖励和交易费。

交易费 = 交易大小 x 费率
- **交易大小**：指的是交易数据的字节大小。一笔交易包括输入、输出和签名等信息，其大小不是固定的。一般来说，交易的输入（来源）越多，交易的大小就越大，因此交易费也可能更高。
- **费率**：通常以“satoshi/byte”（satoshi 是比特币的最小单位，1 BTC = 100,000,000 satoshi）为单位。由用户自己设定，当网络繁忙时，用户可能会选择支付更高的费率以加快交易确认。

### Double spending attack

双重支付攻击：恶意攻击者尝试将同一笔资产同时支付给两个或多个不同的接收者的行为。防范双重支付攻需要用 id 和归属状态。

在比特币中是通过产生该 UTXO 的交易 hash 和锁定脚本（公钥）来解决的（分别对应 id 和归属状态）。

交易里面有一个公钥。发起交易者将会把公钥提供给接受者。而且交易里，币的来源指向的 UTXO 的输出，也有一个公钥指明了归属者。这两个公钥一对比就知道是否由币的拥有者发起的交易。


## 比特币共识（consensus in BitCode）

假设大多数节点是好的，以此设计共识协议。

### 投票-算力
选择交易（判断交易合法）后，广播给所有人，大多数节点同意，则成立。

问题：谁有投票权，Membership，有恶意节点将会影响投票，例如女巫攻击（sybil  attack）（童话故事里女巫可以伪装任何人）。
解决方案：
1. 联盟链，能确保参与人都是好的，没有恶意节点。但中央了
2. 投票用算力决定，而不是数量决定。

比特币中不是按节点数量来决定投票结果，是用算力来决定。这样就解决了女巫攻击，女巫攻击只能伪装更多的节点，在节点数量上提高，但没法提高算力。

其他节点收到广播后验证，Block Head 正确性，里面的 Target 的 nBits 符合比特币规则，Nonce 符合 Target 等。

验证完认可新区块，继续新区块往下扩展。

比特币的共识是账本，而账本只能记账人通过新区块写入，新区块的产生只能靠 hash。
Hash 的 puzzle friendly 保证了没有捷径，只能靠算力。所以说投票权是看算力而不是节点数量。


### 最长链原则

有分叉时，以最长链为合法链。

同一时间产生新区块或广播延迟，产生不同节点视图时，也用最长链原则使得整个区块链一致。

### Forking attack

分叉攻击，攻击者尝试创建一条竞争分支，以便暂时或永久地改变网络的共识。

例如

自私挖矿攻击：
攻击者挖掘新的区块但不立即广播到网络，而是保留这个区块，创建一个私有链。攻击者希望能够在私有链上积累足够长的区块链，然后在适当的时候将其发布到公共网络上，以取代现有的区块链。
收益：获得这些区块的所有出块奖励，而其他矿工因为区块被废弃而损失奖励。要求自身算力足够强。
风险：风险很大，如果中途被其他矿工出块且合法链的长度，比私有链更长，攻击者无法获得任何奖励。

### 恶意节点不认可一个有效的区块

恶意节点占少数，影响是有限的，因为不会影响其他遵守规则节点的共识。

当多数的计算能力（也就是说，多数的节点）认同某个区块链版本时，这个版本就会成为公认的最长链。

### 恶意节点制造欺诈性的交易

恶意节点占少数，影响是有限的，因为不会影响其他遵守规则节点的共识。

如果一个交易被认为是无效的，那么遵循规则的节点不会广播这个交易，也不会将其包含在一个区块中。即使恶意节点将其打包伪装成出块，其他遵守规则的节点对这个区块验证后，也会拒绝这个区块。


## 挖矿

### 特点

Bernoulli trial：伯努利试验，每次 Bernoulli 试验的成功概率是固定的，记为 p，而失败的概率则为 1−p。

挖矿是一个进行 Bernoulli trial 的过程，Bernoulli process，概率上符合指数分布
- 无记忆性：前面的结果对后续的结果是无影响的
 
也叫 Process Free，已经花费的时间是无用功的，对未来没影响。这确保了算力具有按比例的优势，即没有保底机制。

如果不满足 Process Free，那高算力将会有不成比例的优势。例如游戏中的抽卡往往有保底机制，过去的过程对未来会产生影响。假设保底机制是 10 次卡一定会出一个 SSR，一个土豪抽 100 次卡，至少会获得 10 个 SSR，他的奖励范围是  `[10, 100]`。一个萌新抽 5 次卡，他的奖励范围是 
`[0, 5]`。

他们的优势对比是：
- 5 次： `[0, 5]`
- 100 次： `[10, 100]`

成比例的优势对比是：
- 5 次：`[0, 5]`
- 100 次：`[0, 100]`

 Process Free 可以确保成比例的优势，同时也意味着前面挖了多久矿，对未来出矿的时间不会有任何影响。个人挖了 9 分钟，未来出块时间对于个人还是 10 分钟。只是在宏观总体上所有算力是平均 10 分钟出块。
 
### Hash

Hash 时只计算 Block Head，不包含 Block Body。

挖矿是对 Block Head 进行 hash ，只要输出 hash 值满足目标值即挖矿成功，改变 Nonce 的目的也只是为了改变 Block Head。

### Nonce 取值范围不够

随着全网算力提高难度值一直在提高，Nonce 的取值范围已经不够，遍历完可能也找不到一个满足目标难度的，可以用 Merkle Tree 的铸币交易（Coinbase Transaction）的留言（Coinbase Commit）作为 Extra Nonce。

出块奖励是一笔 Coinbase Transaction，矿工会将一笔 Coinbase Transaction 连同选择的交易一起打包，存放到 Block Body 中，通过 Merkle Tree 计算出 Root Hash 存放在 Block Head 里。

对 Coinbase Transaction 的留言 Coinbase Commit 进行更改后，Merkle Tree 生成的 Root Hash 也会改变，对整个 Block Head 进行 hash 计算后的值也会改变，达到了扩展 Nonce 的目的。


真正挖矿调整两个值：
- Nonce
- Coinbase Commit

## 区块链有没有被篡改，只需要核对最后区块的 hash
？区块链有没有被篡改，只需要核对最后区块的 hash 是否正确，就知道有没篡改，问题是验证最后区块的 hash 不是得沿着区块链从头到尾 hash 整条区块链吗？

？Bitcode script

## 确认交易成立

6 个新区块（1 h）之后，只是概率上确认。


## Zero 确认？

应用很广，因为现实中很多因素允许这种乐观成立，例如电商从确认交易后有发货时间，超过 1 h，如果 1 h 后交易没成功，可以不发货。



## 交易冲突

交易被使用过（已经写到区块链里了），就需要在选择进入打包的交易里删除。

？对非法转发这块有点问题
？恶意节点如何进行 double spending attack
？恶意节点转发非法交易包含哪些情况


## 挖矿难度

比特币用的是 sha-256，产生 hash 是 256位。
H (Block Head) <= target

挖矿难度和目标阈值成反比，挖矿难度最小为 1，计算公式：
Difficult = difficult_1_target / target

Difficult_1_target：挖矿难度等于 1 时的目标阈值。


目标阈值（代码中用的是目标阈值）调整公式：
Target = target * 最近 2016 区块 actual time / expected time

目标阈值核验时可以判断字节前面 0 个数是否满足。因为难度越高，目标阈值越小，越小时前面 0 越多。


且有个最大限制，最大不超过 4 倍，最小不小于 1/4，避免遇到特殊情况，挖矿难度被设置得极大或极小

### 难度是如何调难度值，确保所有人都改
写在比特币代码中，都会去执行更改的，不用广播

### 恶意不调难度值
在难度上升时不调，hash 速度会比别人快。

但难度值编码后写在 block head 的 nBit 中，不调难度值将不被其他节点接受。

## 出块时间太短产生的问题

网络传播需要时间，传播时间不够，分叉严重且会成为常态，对区块链的共识不利。

总算力被分叉分散，恶意节点可以集中算力扩展一个分叉，使得替换主链（fu attack？）的攻击变得容易。

产生大量孤块。

## 区块链的安全是如何保证的
	1.	密码学，私钥保证，别人无法转走你的账
	2.	区块链上大部分是好的节点，没有你的签名不会允许转走你的钱


## 扩展：分布式共识（distribute consensus）

### 理论 1： FLP 的不可能结论（ impossibility result ）

在一个异步系统里，网络传输有延迟，不可能存在共识。

### 理论 2： CAP Theorem

任何分布式系统，最多满足下面三个其中两个
- Consistency:  一致性，所有节点在同一时间看到的数据是一致的
- Availability: 可用性，每个请求都会收到一个响应，无论响应是成功还是失败。
- Partition Tolerance：分区容忍性，指系统能够持续提供服务。系统的某些部分之间的网络通信失败，仍然能够继续运行的能力。

### 分布式共识的实现

分布式哈希表（distribute hash table）：`Key：Value` 组成的一个分布式系统
Paxos 协议：一致性


## 待分类处理

第一种方式：pay to public key 最简便
Input script：
2. PUSHDATA (Sig)：签名入栈

Out script：
1. PUSHDATA (PubKey)：收款人公钥入栈。
2. CHECKSIG：前两指令弹出栈，公钥检验签名

后续使用 UTXO 时，直接给出私钥对交易的签名。

脚本执行：先执行输入脚本，再执行输出脚本，结果非零则成功。
1. PUSHDATA (Sig)：签名入栈 
2. PUSHDATA (PubKey)：收款人公钥入栈
3. CHECKSIG：前两指令弹出栈，公钥检验签名

第二种方式：pay to public key hash，最常用

？补充 input  out

第三种方式：pay to public script hash，最复杂

？补充 input  out


输入脚本 scriptSig：
- 签名
- 公钥（最方便的形式）
- 或者通过和交易输出中的 scriptPubKey（锁定脚本）共同执行。

输出脚本 scriptPubKey：
- 公钥（最方便的形式，type 指定 pubkeyHash），或者通过和交易输入中的 scriptSign 共同执行。

？补充交易结构，包含 vin，vout。Vin 里面有来源的 vout


比特币脚本没有循环，不会出现死循环，以太坊合约图灵完备的语言，有循环，需要 gas 来限制避免死循环


比特币每秒交易数目？

Hard fork 分叉是永久的，1 M => 2 M，改后 2 M 旧节点不认可，1 M 新节点不认可。新旧节点对对修改前后各持不认可态度。
Hard fork 分叉后的币的认可？余额不同
分叉后，a 链的交易，去 b 链回放（如何回放？）。防范是通过 chainId 区分两条链

Soft fork，分叉是临时性的，1 M => 0.5 M，改后 0.5 M 新旧节点都认可，1 M 新节点不认可。**改后新旧节点对新规都认可**

UTXO 的定义？

Merkle proof 可以让轻节点验证一个交易是否在给定的区块中。

验证 UTXO 是通过 UTXO 集验证存在，以及输入脚本和输出（锁定）脚本，签名验证归属。

余额需要全节点查询 UTXO 集合，给轻节点，但轻节点没法验证余额的正确性。解决方案：utxo 集合也生成 merkle tree，root hash 写在 coinbase commit 后面几位（前 8 位给 extra Nonce）。

P 2 SH：pay to script hash， soft fork 添加


交易所是中心化的机构，有的要求身份验证的，
这种在私钥丢失可以找回密码。（交易所也可能被黑，并不是它帮你保存密码就安全。交易所出现问题的事件也很多。）

区块链中私钥丢失是无法找回的。
私钥泄露时，要尽快将钱转走。因为无法修改私钥（密码）。
转钱转错了，也没办法取消。

Proof of Burn  OP_RETURN 会抛出错误，既然会抛出错误，那怎么验证通过的？只有验证通过才会写入区块链。
什么算验证通过？
这次交易的输入，与上个交易的输出组合在一起执行验证。
而 RETURN 是在输出脚本，得在想花出这笔交易的时候才会执行，一执行就报错，所以无法交易。
？这种和直接把信息 hash 后作为交易地址有什么区别，前者在 UTXO 集里，后者不在吗？
不在 UTXO 集里，为什么还需要去拼凑输入和输出后去执行？不在 UTXO 集还需要验证这笔交易？

偷 Nonce 是没用的，因为 coinbase transaction 收款人一改，root hash 就变了，整个 block head 的 hash 也跟着变了，Nonce 也就无用了。

1 M 没有装满？为啥不装满？

比特币匿名？
与现实世界产生交接的会破坏匿名性，转入转出会产生联系。区块链是公开的，账单都可以查到，如果知道你在某时候用比特币购物，可以在账单中缩小范围，从而确定哪些账号跟你相关，多几次就确定了。


