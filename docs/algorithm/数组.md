## 双指针
- 大部分双指针解法，都是快慢指针。
- 原地修改数组，基本都是快慢指针。
- 数组有序，大概率是双指针技巧。

### 快慢指针

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)
[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)
[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)
[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/)


### 左右指针
#### 二分查找
```js
var binarySearch = function(nums, target) {
    // 一左一右两个指针相向而行
    var left = 0, right = nums.length - 1;
    while (left <= right) { // 闭区间
        var mid = Math.floor((right + left) / 2);
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
};
```

#### 两数之和
[167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)
```js
var twoSum = function(numbers, target) {
	let left = 0
	let right = numbers.length - 1
	while(left < right) {
		const total = numbers[left] + numbers[right]
		if (total === target) {
			return [left + 1, right + 1]
		} else if (total < target) {
			left++
		} else if (total > target) {
			right--
		}
	}
	return []
};
```

#### 反转数组
[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
```js
var reverseString = function(s) {
	let left = 0
	let right = s.length - 1
	while(left < right) {
		swap(s, left, right)
		left++
		right--
	}
	return s
};
```
 [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/description/) 
 全部翻转，再区间翻转
#### 回文串判断
```js
var isPalindrome = function(s) {
    // 一左一右两个指针相向而行
    let left = 0
    let right = s.length-1;
    while (left < right) {
        if (s.charAt(left) !== s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
};
```


#### 最长的回文串
判断回文串是从两端向中心，求最长回文串是从中心向两端。
- 如果回文串的长度为偶数，则可以认为它有两个中心字符。
- 如果回文串的长度为奇数，则它有一个中心字符；
```js
function palindrome(s, l, r) {
	while (0 <= l && r < s.length && s[l] === s[r]) {
		l--
		r++
	}
	return s.substring(l + 1, r)
}
var longestPalindrome = function(s) {
	let ret = ''
	for (let i = 0; i < s.length; i++) {
		// 假设回文串长度为偶数，两个中心点分别传入 `l`、`r`。
		const even = palindrome(s, i, i + 1)
		// 假设回文串长度为奇数，一个中心点传入 `l`、`r`。
		const odd = palindrome(s, i, i)
		const max = even.length > odd.length? even: odd
		ret = ret.length > max.length? ret: max
	}
	return ret
};

```


## 前缀和
前缀和：原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和
动态规划的一种，当前值与前值有关系，或者可以拆分成若干个前值。只不过题目类型都是与和有关，比动态规划的范畴小。

注意点：
- 新建数组，数组默认为 0，等同初始化 `baseCase`
- 定义： `preSum[i]` 记录了 `[0, i - 1]` 区间的元素和，下标 ` i ` 前缀和不包含本身 ` nums[i]`，熟记这一点思路会清晰很多。

### 一维数组
[303. 区域和检索 - 数组不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-immutable/description/)

![](../assets/20231221-15-09-42.png)
1. 新建数组 preSum `，长度为目标数组长度 + 1。
2. `preSum` 定义为当前下标前的所有值之和，数组第一个值为 0 （`BaseCase`）。每个下标都不包含自身值，值包含下标前所有值之和。

所以有以下定义
```js
this.preSum = [0]
// 添加了 BaseCase ，是为了动态规划表达式边界成立。
// 留意 i <= nums.length  
for (let i = 1; i <= nums.length; i++) {
	this.preSum[i] = this.preSum[i - 1] + nums[i - 1]
}
```

`[left, right]` 区域内的和定义为
```js
// 前缀和的定义是当前下标前所有值之和，不包含本身下标值
// 所以要取到 right 坐标本身的值，便需要 this.preSum[right + 1]
sumRange = function(left, right) {
	return this.preSum[right + 1] - this.preSum[left]
}
```


### 二位数组

[304. 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/)

如果需要求两个坐标内区间的值之和，可以通过分解矩阵，转换成都跟原点相关的矩阵。
![](../assets/20231221-16-14-47.png)

这样就把问题降级了，接下来只需要求从原点到坐标区间和。

`preSum[i][j]` 的定义： 从原点 `[0, 0]` 到 `[i - 1, j - 1]` 所有值之和
所以我们要求区间原点至 `(x,y)` 之和，需要的是 `preSum[x+1][y+1]`

```js
var NumMatrix = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    // `preSum[i][j]` 的定义： 从原点 `[0, 0]` 到 `[i - 1, j - 1]` 所有值之和
    this.preSum = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(0)) // base case

	// 计算每个矩阵 [0, 0, i, j] 的元素和
    for (let i = 1; i <= m; i++) { // 从 1 开始
        for (let j = 1; j <= n; j++) { // 从 1 开始
            this.preSum[i][j] = this.preSum[i - 1][j] + this.preSum[i][j - 1] + matrix[i - 1][j - 1] - this.preSum[i - 1][j - 1]
        }
    }
};

NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
	// 所以我们要求区间原点至 `(x,y)` 之和，需要的是 `preSum[x+1][y+1]`
	// 区间内矩阵和通过分解矩阵，转换成都跟原点相关的矩阵。
    return this.preSum[row2 + 1][col2 + 1] - this.preSum[row1][col2 + 1] - this.preSum[row2 + 1][col1] + this.preSum[row1][col1] 
};
```




## 差分数组
**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。O (1) 复杂度修改。

定义：**`diff[i]` ： `nums[i]` 和 `nums[i-1]` 之差**

![](../assets/20231223-16-35-22.png)
```js
var diff = new Array(nums.length);
// 构造差分数组
diff[0] = nums[0];
for (var i = 1; i < nums.length; i++) {
    diff[i] = nums[i] - nums[i - 1];
}
```

通过这个 `diff` 差分数组是可以反推出原始数组 `nums`。
当前值等于上一个值加上当前值与上值差值。
`res[i]`：`res[i - 1]` + `diff[i]`
```js
var nums = new Array(diff.length);
// 根据差分数组构造结果数组
nums[0] = diff[0];
for (var i = 1; i < diff.length; i++) {
    nums[i] = nums[i - 1] + diff[i];
}
```

**差分数组可以快速进行区间增减的操作**，如果想对区间 `nums[i..j]` 的元素全部加 3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可

**原理很简单，回想 `diff` 数组反推 `nums` 数组的过程，`diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了 3，然后 `diff[j+1] -= 3` 又意味着对于 `nums[j+1..]` 所有元素再减 3，那综合起来对 `nums[i..j]` 中的所有元素都加 3**

[1109. 航班预订统计 - 力扣（LeetCode）](https://leetcode.cn/problems/corporate-flight-bookings/description/)
[1094. 拼车 - 力扣（LeetCode）](https://leetcode.cn/problems/car-pooling/description/)

``` js
class Difference {
    constructor (nums) {
        this.diff = []
        const { length } = nums
        if(!length) return
        this.diff[0] = nums[0]
        for(let i = 1; i < length; i++) {
            this.diff[i] = nums[i] - nums[i - 1]
        }
    }
    increment(i, j, val) { /* 给闭区间 [i, j] 增加 val（可以是负数）*/
        this.diff[l] += val
        if (j + 1  > this.diff.length - 1) return // 如果超过范围，说明是对 nums[i] 及以后的整个数组都进行修改，不需要减了
        this.diff[j + 1] -= val
    }
    result() { /* 返回结果数组 */
        const nums = []
        const { length } = this.diff
        if (!length) return nums
        nums[0] = this.diff[0]

        for (let i = 1; i < length; i++) {
            nums[i] = nums[i - 1] + this.diff[i]
        }
        return nums
    }
}
```



## 二维数组遍历-技巧
记技巧，会者不难，不会者难的类型

### 顺/逆时针旋转矩阵

[48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/)
![](../assets/20231224-17-59-55.png)

解法：
1. 按照左上到右下的对角线进行镜像对称
	![](../assets/20231224-18-00-11.png)
2. 再对矩阵的每一行进行反转
	![](../assets/20231224-18-00-41.png)
这样**顺时针旋转 90 度**完成。
旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。
```js
const n = matrix.length
// 左上到右下对角线镜像对称
for (let i = 0; i < n; i++) {
	for (let j = i; j < n; j++) {
		swap(matrix, i, j, j, i)
	}
}
```

同样也可以实现逆时针选择 90 度，从右上到左下对角线镜像对称，再行翻转。
```js
const n = matrix.length
// 右上到左下对角线镜像对称
for (let i = n; i >= 0; i--) {
	for (let j = n - 1 - i; j >= 0; j--) {
		swap(matrix, i, j, n - 1 - j, n - 1 - i)
	}
}
```

### 矩阵的螺旋遍历
[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/)
![](../assets/20231224-20-27-14.png)
```js
var spiralOrder = function(matrix) {
	    let left = 0, top = 0, right = matrix[0].length - 1, bottom = matrix.length - 1
	    let dire = 0
	    const ret = []
	    while (left <= right && top <= bottom) {
	        if (dire === 0) { // 向右
	            let j = left
	            while( j <= right) { // 不超过右边缘
	                ret.push(matrix[top][j])
	                j++
	            }
	            top++ // 上边界都处理过了，上边界往中间缩
	        } else if (dire === 1) {
	            let i = top
	            while ( i <= bottom) {
	                ret.push(matrix[i][right])
	                i++
	            }
	            right--
	        } else if (dire === 2) {
	            let j = right
	            while ( j >= left) {
	                ret.push(matrix[bottom][j])
	                j--
	            }
	            bottom--
	        } else if (dire === 3) {
	            let i = bottom
	            while ( i >= top) {
	                ret.push(matrix[i][left])
	                i--
	            }
	            left++
	        }
	        
	        dire = ++dire % 4
	    }
	    return ret
};
```



## 滑动窗口
### 基础
解决子串问题。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」

左右指针维护一个窗口，不断滑动，同时更新答案。
时间复杂度: `O(N)`

需要留意
- 移动 `right` 前，应该更新进入窗口 (right) 的数据，后移动 ` right ` 扩大窗口。
- 满足条件时窗口应该暂停扩大，缩小窗口前应该更新离开窗口（left）的数据，后移动 `left` 缩小窗口。
- 结果应该在扩大窗口时更新，并在缩小窗口时进行反向更新。

思路：
1. 在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。
2. 不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。
3. 此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

> 理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。
> 如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；
> 如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，欲找到一个「最优解」。**

```js
var slidingWindow = function(s) {
    // 用合适的数据结构记录窗口中的数据
    const map = new Map();
    
    let left = 0, right = 0;
    while (right < s.length) {
        // c 是将移入窗口的字符
        let c = s[right];
        map.set(c, (map.get(c) || 0) + 1);
         // 进行窗口内数据的一系列更新
        ...
        
        // 增大窗口，且是左闭右开
        right++; 
       

        console.log("window: [" + left + ", " + right + ")");
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (left < right && window needs shrink) { // 如果是固定长窗口（固定长窗口例如判断 right - left === xx.size ），由于只移除1个字符,可以将 while 改成 if
            // d 是将移出窗口的字符
            let d = s[left];
            map.set(d, map.get(d) - 1);
            // 进行窗口内数据的一系列更新
            ...
            
            // 缩小窗口
            left++;
            
        }
    }
}
```
这两个 `...` 处的操作分别是扩大和缩小窗口的更新操作，它们操作是完全对称的。**为了避免弯弯绕绕，请记得反操作代码顺序也要对称。**

虽然滑动窗口代码框架中有一个嵌套的 while 循环，但算法的时间复杂度依然是 `O(N)`。
> 指针 `left, right` 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比。


[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/)

该题思路图
-  `needs` 计数器：记录 `T` 中字符出现次数。
-  `window` 计数器：「窗口」中的相应字符的出现次数。
![](../assets/20231226-15-58-00.png)

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符
![](../assets/20231226-16-00-22.png)

此时，开始增加 `left`，缩小窗口 `[left, right)`
![](../assets/20231226-16-01-32.png)

直到窗口中的字符串不再符合要求，`left` 不再继续移动。重复上述过程，先移动 `right`，再移动 `left` …… 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

```js
var minWindow = function(s, t) {
    let left = 0, right = 0, start = 0, length = Infinity
    const tMap = new Map()
    for (let i = 0; i < t.length; i++) {
        const str = t[i]
        tMap.set(str, (tMap.get(str) || 0) + 1)
    }

    const map = new Map()
    while(right < s.length) {
        const r = s[right]
        map.set(r, (map.get(r) || 0) + 1)
        right++

        while (left < right && isInWindow({map, tMap})) {
            const l = s[left]
            map.set(l, (map.get(l) || 0) - 1)
            
            const len = right - left
            left++

            if (length < len) {
                continue
            }

            length = len
            start = left - 1
        }
    }
    if (length === Infinity) return ''

    return s.substr(start, length)
};

// 当然可以优化掉该方法， 用一个计数器变量记录已满足字符串的数量
const isInWindow = ({map, tMap}) => {
    if (map.size < tMap.size) return false
    const entires = tMap.entries()
    for (let entry of entires) {
        const [s, tNum] = entry
        const num = map.get(s) || 0
        if (num < tNum) {
            return false
        }
    }
    return true
}
```







[567. 字符串的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutation-in-string/description/)
这道题与上一道的区别是，连续的字符。
留意反操作，是先判断计数器，再修改 needs。
> 因为当前元素离开前，如果 needs 中为 0，意味着该字符原本是满足数量的，但即将被打破，所以计数器减一。
> 如果顺序颠倒先更新 needs 再更新计数器，那么需要修改判断条件为 `if (needs.get(d) === 1)`  因为 left 移开窗口后，当前字符缺少了 1，移开之前该字符是处于满足状态，满足状态被打破了，计数器也要同步减一。为了避免弯弯绕绕，请记得反操作代码顺序也要对称。
```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
    const needs = new Map()
    for (let s of s1) {
        needs.set(s, (needs.get(s) || 0) + 1)
    }
    let left = 0, right = 0, validate = 0
    const {length} = s2
    while (right < length) {
        const s = s2[right] // 因为左闭右开，此时的right是进入window的元素
        if (needs.has(s)) {
            needs.set(s, needs.get(s) - 1)
            if (needs.get(s) === 0) {
                validate++
            }
        }
        right++ // 左必右开

        while (validate === needs.size) {
            // 满足条件的子串，长度肯定跟s1一致
            const d = s2[left] // 即将离开window的元素
            /* 留意这里 */
            if (needs.has(d)) { // 反操作，留意是先判断计数器，再修改 needs
                if (needs.get(d) === 0) {
                    validate--
                }
                needs.set(d, needs.get(d) + 1)
            }
            if (right - left === s1.length) return true

            left++

        }
    }

    return false
};
```
如果维护的是一个**固定长**的窗口，窗口大小为 `needs.size()`。因为固定长的窗口每次向前滑动时只会移出一个字符，所以可以把内层的 while 改成 if，效果是一样的。

[438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)


[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

这里有个特殊点，维护数据在哪个阶段？或者说哪一个阶段可以保证窗口中的字符串是没有重复？
```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    const map = new Map()
    let left = 0, right = 0, len = 0 
    const {length} = s
    while (right < length){
        const r = s[right]
        map.set(r, (map.get(r) || 0) + 1)
        right++

        while(map.get(r) > 1) { // 重复了，长度不在里面计算
            const l = s[left]
            map.set(l, map.get(l) - 1)
            
            left++
        }
        // 只有在跳出重复这个循环后，才能确保是不重复的,
        // 范围是[left, right)，计算长度: right - left 
        // 不用 + 1.  [left, right] 才需要 + 1. 可以参考 [0, 0) 和 [0, 0]
        len = Math.max(len, right - left)
    }
    if (!left) return length

    return len
};

```


### 扩展-Rabin-Karp
**在滑动窗口中快速计算窗口中元素的哈希值，叫做滑动哈希技巧**。

提供给你源数字 number ，请你在最低位添加一个数字 appendVal。例如 number= 8264，appendVal = 3，返回 82643。
```js
let number = 8264
const appendVal = 3
const R = 10 // 进制
number = number * R + appendVal // 82643
```

提供给你源数字 number ，请你在最高位删除一个数字。例如 number= 8264，返回 264。
```js
let number = 8264
const removeVal = 3
const R = 10 // 进制
const L = 4 // number 位数
number = number - removeVal * R^(L - 1) // 264
```
`Rabin-Karp` 便是基于以上两个原理


[187. 重复的DNA序列 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-dna-sequences/description/)
子串问题，长度为 10，即代入滑动窗口模版
```js
var slidingWindow = function(s) {
    // 用合适的数据结构记录窗口中的数据
    const map = new Map();
    
    let left = 0, right = 0;
    while (right < s.length) {
        // c 是将移入窗口的字符
        let c = s[right];
         // 进行窗口内数据的一系列更新
        ...
        
        // 增大窗口，且是左闭右开
        right++; 
       

        console.log("window: [" + left + ", " + right + ")");
        /********************/
        
        // 判断左侧窗口是否要收缩
        if (right - left === 10) { // 如果是固定长窗口（固定长窗口例如判断 right - left === xx.size ），由于只移除1个字符,可以将 while 改成 if
            // d 是将移出窗口的字符
            let d = s[left];
            // 进行窗口内数据的一系列更新
            ...
            
            // 缩小窗口
            left++;
        }
    }
}
```
如果是暴力解，字符串记录读取后 10 个需要额外时间。用滑动窗口使得窗口长度为 10，通过移动可以节省每次读 10 个的时间。
为了校验重复，还需要记录占用大量额外空间，如果可以将这 10 个字符串通过一个类似一个哈希函数的方法转换成一个数字，那么将节省大量空间。

基于上面两个原理，在最低位增加数字，在最高位删除数字，这便是对应滑动窗口的挪动。
至于进制，便需要将题目抽象成对应数字状态值（例如题目中的 `'A'`, `'C'`, `'G'` `'T'` 对应 `0 - 3 `）。

